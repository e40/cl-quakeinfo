
	Earthquake data via the USGS website with Common Lisp

Recently we had a bunch of small earthquakes in the Oakland, CA area.
I thought it would be fun to use Allegro Common Lisp to retrieve and
display information about recent earthquakes.

I found that the USGS website has hourly, daily and weekly quake data
available here:

   http://earthquake.usgs.gov/eqcenter/recenteqsww/catalogs/

Possible formats of interest to me: XML (RSS) and CSV.  I decided to
use the CSV format, comma separate files, since XML seemed like
overkill.

What I wanted to do was to find recent earthquakes near where I lived.
However, the data from USGS is of the form:

  Src,Eqid,Version,Datetime,Lat,Lon,Magnitude,Depth,NST
  ak,00074326,5,"January 09, 2007 23:59:55 GMT",64.1478,-150.1976,1.8,1.00,07

Time, location (latitude and longitude in decimal degrees) and
magnitude, among other bits of data.  The data is nice, but I needed
two things to make it useful:

  1. filter out the coordinates I didn't want, and
  2. convert latitude/longitude coordinates into city names.

An implication of (1) is that I needed an easy way to convert a place
name to coordinates, because if I want the facility to work for more
than just my location, others will need an easy way to look up their
own location.  Fortunately, Googles Maps
[http://www.google.com/apis/maps/documentation/] provides this
information.  Their API requires that you supply a key assigned to
you.  (You can obtain a key from Google here
[http://www.google.com/apis/maps/signup.html].)

That makes it fairly easy to write a function place-to-location:

  cl-user(7): (place-to-location "Oakland, CA")
  #<location 37.804443,-122.26972>
  cl-user(8): (place-to-location "Berkeley, CA")
  #<location 37.871666,-122.27167>
  cl-user(9): (location-to-place (place-to-location "Berkeley, CA"))
  "Berkeley, California"
  cl-user(10): (location-to-place
		(place-to-location
		 "2629 College Ave, Berkeley, CA"))
  "Berkeley, California"
  cl-user(11): (place-to-location "2629 College Ave, Berkeley, CA")
  #<location 37.86319,-122.25365>
  cl-user(12): 

Lastly, to help me get a feel for how to filter the data I wanted to
know the distance between to locations.  I used the "Great Circle
Distance" Formula.  Some examples (distances are in miles):

  cl-user(17): (distance-between
		(place-to-location "Boulder, CO")
		(place-to-location "Piedmont, CA"))
  923.7414773838934d0
  cl-user(18): (distance-between
		(place-to-location "Lake Wylie, SC")
		(place-to-location "Piedmont, CA"))
  2283.922367943316d0
  cl-user(19): 

Converting location coordinates into city names turned out to be
tricky.  There is no readily available web resource that will do this
(like Google Maps). I did find The Zip Code Database Project
[http://sourceforge.net/project/showfiles.php?group_id=111073] which
contains location coordinates for each zip code, and the data includes
the names of the cities for each zip code.  It's a fairly simple matter
to find the nearest match for a set of coordinates.

I also found it convenient to make `measures' module that contained a
`location' object, made up of `latitude' and `longitude'.  The
`measures' API also contains the `distance-between' and
`location-near-p' functions.

The `zipcodes' module provides the `location-to-zip' function, and the
`google-maps' module uses this to provide `location-to-place' and
`place-to-location'.

Putting it all together, we can do something like this:

  cl-user(8): (get-quake-info
	       :period :week
	       :larger-than nil
	       :within 1.0
	       :reference-location 
	       (place-to-location
		"555 12th St, Oakland, CA, 94607, US"))
  ;; Downloading data...done.
  January 09, 2007 22:33:42 GMT: Hollister, California: magnitude=3.1
  January 09, 2007 22:16:21 GMT: Los Altos, California: magnitude=2.0
  January 09, 2007 21:39:52 GMT: Hollister, California: magnitude=1.3
  January 09, 2007 16:56:54 GMT: Aromas, California: magnitude=1.4
  January 09, 2007 13:20:02 GMT: Cobb, California: magnitude=1.4
  January 09, 2007 11:52:11 GMT: Hayward, California: magnitude=1.2
  January 09, 2007 03:01:03 GMT: El Cerrito, California: magnitude=1.9
  January 08, 2007 11:30:55 GMT: San Jose, California: magnitude=2.0
  January 07, 2007 14:22:56 GMT: Walnut Creek, California: magnitude=1.2
  January 07, 2007 09:20:38 GMT: Kenwood, California: magnitude=3.1
  January 06, 2007 12:58:01 GMT: Yountville, California: magnitude=1.8
  January 06, 2007 07:04:01 GMT: Oakland, California: magnitude=2.4
  January 05, 2007 22:55:53 GMT: Walnut Creek, California: magnitude=1.3
  January 05, 2007 20:18:51 GMT: Livermore, California: magnitude=2.4
  January 05, 2007 17:54:17 GMT: Ladera, California: magnitude=1.1
  January 05, 2007 11:09:43 GMT: Cobb, California: magnitude=2.4
  January 05, 2007 10:40:26 GMT: Concord, California: magnitude=1.3
  January 04, 2007 20:38:03 GMT: Los Altos, California: magnitude=1.7
  January 04, 2007 20:21:41 GMT: Aromas, California: magnitude=2.6
  January 04, 2007 13:42:36 GMT: Palo Alto, California: magnitude=1.2
  January 04, 2007 03:42:10 GMT: Oakland, California: magnitude=1.9
  nil
  cl-user(9): 

The :within keyword value is in decimal degrees.  A degree of latitude
is approximately 69 miles.  So 3.0 degrees is a little more than 200
miles in latitude.  I use this for longitude, as well, but a degree of
longitude changes with latitude, from 69 at the equator to 0 at the
north and south poles.

The :period keyword value can be :hour, :day or :week.

The :larger-than keyword is a filter on magnitude.  `nil' means all
quakes.  `2.0' means those later than 2.0.

*******************************************************************************
IMPLEMENTATION DETAILS
*******************************************************************************

For those that want to know more about how this example was
implemented, this section is for you.

Zip codes

The zip code data, from the The Zip Code Database Project, comes in a
large CSV file and has the following form:

  "zip code", "state abbreviation", "latitude", "longitude", "city", "state"
  "35004", "AL", " 33.606379", " -86.50249", "Moody", "Alabama"
  ...

There 33,178 entries in the file.  It is best if the compiled version
of the module is not dependent on this data file, so the data file has
to be read at compile time and saved in the fasl file.  I'm thinking a
special variable bound to a simple vector of zip code structures.

It would be simple matter to create, at compile time, a simple vector
of zip structs, and to use make-load-form on the structure objects so
they can be written out by the compiler.  It turns out that because
the compiler must do circularity detection and using make-load-form is
fairly expensive, having the compiler write out a simple vector of
33000+ struct objects is a very slow process, one that creates a lot
of garbage and uses lots of memory.  So, we use an alternate
implementation to read in the data file so the data can be constructed
at load time: at compile time save each slot of the raw data in a
separate vector, and assemble these vectors into the final data
structure at load time.  It turns out this implementation much more
efficient than the naive implementation discussed first, above.  The
details:

This happens at compile time:

(defvar *zipcode-data*
    #.(let ((zips
	     (prog2
		 (progn (format t "reading zips.cvs...")
			(force-output))
		 (read-zips-csv 
		  (merge-pathnames "zips.csv" *compile-file-pathname*))
	       (format t "done~%"))))
	(list 'list
	      (vector-of zips #'zip-code)
	      (vector-of zips #'zip-state-abbrev)
	      (vector-of zips (lambda (zip)
				(let ((loc (zip-location zip)))
				  (cons (location-latitude loc)
					(location-longitude loc)))))
	      (vector-of zips #'zip-city)
	      (vector-of zips #'zip-state))))

The #. means that the compiler reads the form returned by evaluating
the (let ...).  That form is a list of vectors containing the target
data.  Then, we do this at load time:

(defvar *zipcodes*
    (destructuring-bind (codes abbrevs locations cities states)
	*zipcode-data*
      (do* ((max (length codes))
	    (zips (make-array max))
	    (i 0 (1+ i)))
	  ((= i max) zips)
	(setf (svref zips i)
	  (make-zip :code (svref codes i)
		    :state-abbrev (svref abbrevs i)
		    :location (let ((loc (svref locations i)))
				(make-location
				 :latitude (car loc)
				 :longitude (cdr loc)))
		    :city (svref cities i)
		    :state (svref states i))))))

(setq *zipcode-data* nil) ;; no longer needed, GC it

*******************************************************************************
INSTALLATION
*******************************************************************************

Unpack the .tgz file.  In the same directory where you unpack the
files, create a file called "google-maps-key.cl" which contains your
Google Maps API key.  Something like this:

  (setq util.google.maps:*default-key*
    "...long string of characters obtained from google...")

Then, you are ready to start up Allegro CL in the directory where you
unpacked the source files, type 

  :ld .asdf

That should print something like this:

  cl-user(2): :ld .asdf
  ; Loading /home/layer/src/.asdf
  ;   Fast loading /backup/acl/acl80/code/asdf.001
  ;;; Installing asdf patch, version 1
  ; loading system definition from /home/layer/src/usgs.asd into
  ; #<The asdf0 package>
  ;   Loading /home/layer/src/usgs.asd
  ; registering #<system usgs @ #x71d10132> as usgs
  ; loading system definition from google/google.asd into #<The asdf0 package>
  ;   Loading /home/layer/src/google/google.asd
  ; registering #<system google @ #x71d1a762> as google
  ; loading system definition from zipcodes/zipcodes.asd into
  ; #<The asdf0 package>
  ;   Loading /home/layer/src/zipcodes/zipcodes.asd
  ; registering #<system zipcodes @ #x71d231aa> as zipcodes
  ; loading system definition from measures/measures.asd into
  ; #<The asdf0 package>
  ;   Loading /home/layer/src/measures/measures.asd
  ; registering #<system measures @ #x71d2c082> as measures
  ;;; Compiling file /home/layer/src/measures/measures.cl
  ;;; Writing fasl file /home/layer/src/measures/measures.fasl
  ;;; Fasl write complete
  ;   Fast loading /home/layer/src/measures/measures.fasl
  ;;; Compiling file /home/layer/src/zipcodes/zip-package.cl
  ;;; Writing fasl file /home/layer/src/zipcodes/zip-package.fasl
  ;;; Fasl write complete
  ;;; Compiling file /home/layer/src/zipcodes/zip-util.cl
  ;   Fast loading /home/layer/src/zipcodes/zip-package.fasl
  ;;; Writing fasl file /home/layer/src/zipcodes/zip-util.fasl
  ;;; Fasl write complete
  ;;; Compiling file /home/layer/src/zipcodes/zip-api.cl
  ;   Fast loading /home/layer/src/zipcodes/zip-package.fasl
  ;   Fast loading /home/layer/src/zipcodes/zip-util.fasl
  reading zips.cvs...done
  ;;; Writing fasl file /home/layer/src/zipcodes/zip-api.fasl
  9095168 bytes have been tenured, next gc will be global.
  See the documentation for variable *global-gc-behavior* for more information.
  ;;; Fasl write complete
  ;   Fast loading /home/layer/src/zipcodes/zip-package.fasl
  ;   Fast loading /home/layer/src/zipcodes/zip-util.fasl
  ;   Fast loading /home/layer/src/zipcodes/zip-api.fasl
  ;;; Compiling file /home/layer/src/google/google-maps.cl
  ;   Fast loading /backup/acl/acl80/code/aserve.004
  ;;; Installing aserve patch, version 4
  ;     Fast loading from bundle code/acldns.fasl.
  ;;; Installing acldns patch, version 1
  ;;; Writing fasl file /home/layer/src/google/google-maps.fasl
  ;;; Fasl write complete
  ;   Fast loading /home/layer/src/google/google-maps.fasl
  ;;; Compiling file /home/layer/src/usgs.cl
  ;   Fast loading /backup/acl/acl80/code/regexp2.001
  ;;; Installing regexp2 patch, version 1
  ;     Fast loading /backup/acl/acl80/code/yacc.001
  ;;; Installing yacc patch, version 1
  ;   Fast loading /backup/acl/acl80/code/update.fasl
  ;;; Installing update patch, version 6
  ;     Fast loading /backup/acl/acl80/code/crc.fasl
  ;     Fast loading /backup/acl/acl80/code/inflate.fasl
  ;       Fast loading from bundle code/iodefs.fasl.
  ;         Fast loading from bundle code/iordefs.fasl.
  ;           Fast loading /backup/acl/acl80/code/efmacs.002
  ;;; Installing efmacs patch, version 1
  ;;; Writing fasl file /home/layer/src/usgs.fasl
  ;;; Fasl write complete
  ;   Fast loading /home/layer/src/usgs.fasl
  ;     Loading /home/layer/src/google-maps-key.cl
  ;; Try this:

  (get-quake-info :period :week
    :larger-than nil
    :within 1.0
    :reference-location (place-to-location
			   "555 12th St, Oakland, CA, 94607, US"))
  cl-user(3): 

Now, you can evaluate the form printed just before the prompt to see
if it works for you.
